use std::str::FromStr;
use crate::*;
use crate::lexer::*;

grammar;

// ============================================================ extern

extern {
    type Error = ();
    type Location = usize;

    enum Token {
        Comment => Token::Comment(<String>),
        
        PrototypeDefStart => Token::PrototypeDefStart(<String>),
        AtomPath => Token::AtomPath(<String>),
        
        VarInt => Token::VarInt(<(String, f64)>),
        VarNull => Token::VarNull(<(String, ())>),
        VarString => Token::VarString(<(String, String)>),
        VarPath => Token::VarPath(<(String, String)>),
        VarList => Token::VarList(<(String, Vec<i32>)>),
        VarListString => Token::VarListString(<(String, Vec<String>)>),
        VarEnd => Token::VarEnd,
        
        RowDefStart => Token::RowDefStart(<Vec<i32>>),
        PrototypeId => Token::PrototypeId(<String>),
        RowDefEnd => Token::RowDefEnd,
        
        EmptyLine => Token::EmptyLine,
    
        Err => Token::Err,
    }
}

// ============================================================ grammar

Var: Var = {
    <v:VarInt>          => Var { name: v.0, val: VarVal::Int(v.1), },
    <v:VarString>       => Var { name: v.0, val: VarVal::String(v.1), },
    <v:VarPath>         => Var { name: v.0, val: VarVal::Path(v.1), },
    <v:VarList>         => Var { name: v.0, val: VarVal::List(v.1), },
    <v:VarListString>   => Var { name: v.0, val: VarVal::ListString(v.1), },
    <v:VarNull>         => Var { name: v.0, val: VarVal::Null, },
}

Atom: Atom = {
    <p:AtomPath>
        => Atom { path: p, vars: vec![], },
    <p:AtomPath> <v:Var+> VarEnd
        => Atom { path: p, vars: v, },
}

Prototype: Prototype = {
    <i:PrototypeDefStart> <a:Atom+>
        => Prototype { id: i, atoms: a, },
}

Row: Row = {
    <i:RowDefStart> <t:PrototypeId+> RowDefEnd
        => Row { coords: i, tiles: t, },
}

pub Dmm: Dmm = {
    <c:Comment> <p:Prototype+> EmptyLine <r:Row+>
        => Dmm { comment: c, prototypes: p, rows: r},
}
