use std::str::FromStr;
use crate::*;

grammar;

CommaSep<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

SemicolSep<T>: Vec<T> = {
    <mut v:(<T> ";")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

QuotedStr: String = <s:r#""[a-zA-Z0-9,. ]*""#> "\"" => s.to_string();

AtomPath: String = <p:r"/[a-z][a-z0-9_/]*"> => p.to_string();

ProtoId: String = <i:r"[a-zA-Z]+"> => i.to_string();

Num: i32 = <s:r"[0-9]+"> => { dbg!(&s); i32::from_str(&s).unwrap() };

Comment: String = {
    <c:r"//[A-Za-z0-9., ]+"> => c.to_string(),
}

VarVal: VarVal = {
    <s:QuotedStr> => VarVal::String(s),
    <n:Num> => VarVal::Int(n),
    "list(" <l:CommaSep<Num>> ")" => VarVal::List(l),
}

Var: Var = {
    <n:ProtoId> " = " <v:VarVal> => Var { name: n, val: v }
}

Atom: Atom = {
    <p:AtomPath> => Atom { path: p.to_string(), vars: vec![] },
    <p:AtomPath> "{" <v:SemicolSep<Var>> "}" => Atom { path: p.to_string(), vars: v },
}

Prototype: Prototype = {
    <id:QuotedStr> " = (" <a:CommaSep<Atom>> ")"
    => Prototype { id: id.to_string(), atoms: a}
}

Row: Row = {
    "(" <c0:Num> "," <c1:Num> "," <c2:Num> ")" "=" "{\"" <t:ProtoId*> "\"}"
    => Row { coords: vec![c0, c1, c2], tiles: t.iter().map(|s| s.to_string()).collect(), },
}

pub Dmm: Dmm = {
    <c:Comment> <p:Prototype+> <r:Row+>
    => Dmm { comment: c, prototypes: p, rows: r}
}